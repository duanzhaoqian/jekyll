---
layout: post
title:  "linux 命令"
date:   2016-05-25
desc: "linux 命令"
keywords: "linux,shell"
categories: [Linux]
tags: [linux,shell]
icon: fa-linux
---

# Linux相关操作

## 查看系统信息

```
cat /proc/version 查看系统版本
uname -a
cat /proc/cpuinfo
cat /etc/redhat-release 
getconf -a 查看系统所有变量
getconf LONG_BIT 查看系统位数
```

```
# uname -a # 查看内核/操作系统/CPU信息 
# head -n 1 /etc/issue # 查看操作系统版本 
# cat /proc/cpuinfo # 查看CPU信息 
# hostname # 查看计算机名 
# lspci -tv # 列出所有PCI设备 
# lsusb -tv # 列出所有USB设备 
# lsmod # 列出加载的内核模块 
# env # 查看环境变量资源 
# free -m # 查看内存使用量和交换区使用量 
# df -h # 查看各分区使用情况 
# du -sh <目录名> # 查看指定目录的大小 
# grep MemTotal /proc/meminfo # 查看内存总量 
# grep MemFree /proc/meminfo # 查看空闲内存量 
# uptime # 查看系统运行时间、用户数、负载 
# cat /proc/loadavg # 查看系统负载磁盘和分区 
# mount | column -t # 查看挂接的分区状态 
# fdisk -l # 查看所有分区 
# swapon -s # 查看所有交换分区 
# hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备) 
# dmesg | grep IDE # 查看启动时IDE设备检测状况网络 
# ifconfig # 查看所有网络接口的属性 
# iptables -L # 查看防火墙设置 
# route -n # 查看路由表 
# netstat -lntp # 查看所有监听端口 
# netstat -antp # 查看所有已经建立的连接 
# netstat -s # 查看网络统计信息进程 
# ps -ef # 查看所有进程 
# top # 实时显示进程状态用户 
# w # 查看活动用户 
# id <用户名> # 查看指定用户信息 
# last # 查看用户登录日志 
# cut -d: -f1 /etc/passwd # 查看系统所有用户 
# cut -d: -f1 /etc/group # 查看系统所有组 
# crontab -l # 查看当前用户的计划任务服务 
# chkconfig –list # 列出所有系统服务 
# chkconfig –list | grep on # 列出所有启动的系统服务程序 
# rpm -qa # 查看所有安装的软件包
iostat 显示存储细节
cat /proc/meminfo 显示内存使用 
mpstat -P ALL 显示每个CPU状态
pmap 显示进程占用内存量
pstree -p 显示进程父子关系
```

16个Linux服务器监控命令
[http://roclinux.cn/?p=2549](http://roclinux.cn/?p=2549)

## tail

```
 tail -f catalina.out|grep --color -B 20 'com.ync365.seed.service.user.impl'
```
## 关闭selinux

打开`/etc/selinux/config`，把`SELINUX=enforcing`改为`SELINUX=disabled`

```
vi /etc/selinux/config
```

## cp 实现强行覆盖 

`alias`

```bash
[root@localhost storage]# alias
alias cp='cp -i'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias mv='mv -i'
alias rm='rm -i'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
[root@localhost storage]# 
```
方法一

`unaslias cp`（这只是临时取消cp的别名，不是永久的）

```bash
[root@localhost ~]#unaslias cp
```
方法二

输入\cp命令，作用也是取消cp的别名。

```bash
[root@localhost ~]#\cp -fr src dest
```

方法三

输入`yes|cp -fr src dest`，使用管道自动输入yes。

```bash
[root@localhost ~]#yes | cp cp -fr src dest 
```

让管道自动输入一大堆得yes，就可以完成了强行复制了。
那有人会问dos的copy命令怎么实现强行复制的呢？答案是
用来 `xcopy /y src dest` 来实现强行复制。

## pkill命令

来自: http://man.linuxde.net/pkill

pkill命令可以按照进程名杀死进程。pkill和killall应用方法差不多，也是直接杀死运行中的程序；如果您想杀掉单个进程，请用kill来杀掉。

语法 

```
pkill(选项)(参数) 

```

选项 

```
-o：仅向找到的最小（起始）进程号发送信号； 
-n：仅向找到的最大（结束）进程号发送信号； 
-P：指定父进程号发送信号； 
-g：指定进程组； 
-t：指定开启进程的终端。 
```

参数 

进程名称：指定要查找的进程名称，同时也支持类似grep指令中的匹配模式。 

实例 

```
pgrep -l gaim 
2979 gaim 

pkill gaim 
```

也就是说：kill对应的是PID，pkill对应的是command。

## nohup

nohup 的用途就是让提交的命令忽略 hangup 信号。

在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上"&"来将命令同时放入后台运行，也可用">filename 2>&1"来更改缺省的重定向文件名。

nohup 示例

```
[root@xx ~]# nohup ping www.ibm.com &
[1] 3059
nohup: appending output to `nohup.out'
[root@pvcent107 ~]# ps -ef |grep 3059
root      3059   984  0 21:06 pts/3    00:00:00 ping www.ibm.com
root      3067   984  0 21:06 pts/3    00:00:00 grep 3059
[root@xx ~]#
```

## 时间设置

### linux时间快8小时解决办法

要解决这个问题，首先要确认当前CMOS显示的时间是否是当前的时间，如果是则你的CMOS是非UTC时间（即CST当地时间），要修改`/etc/sysconfig/clock`文件，将里面的UTC=true 改为 UTC=false （告诉Linux硬件设置的是当地时间）

这个是多数快8小时的原因，因为安装Linux时默认选项是使用UTC时间（可能国外电脑的CMOS都是设置的UTC时间），系统误认为你的CMOS是UTC时间，而你又选择了＋8的时区，所以Linux在CMOS时间上加了8小时作为系统的时间 

更改时区

```
rm /etc/localtime

ln -s /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime
``` 

读取硬件时间到系统

```
clock --hctosys
```

输入Date查看当前是否为 CST时间（CST表示当地时间，如我们设置的Shanghai  ），如果时间不正确用以下方式修改时间

```
date -s 2010-02-03 12:00:00
```

将系统时间写入硬件

```
clock --systohc 
```

### ntp安装

```
yum install -y ntp
```

设置ntp服务器

```
vim /etc/ntp.conf 
```

```
# Hosts on local network are less restricted.
#restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap
restrict 192.168.0.0 mask 255.255.0.0 nomodify notrap
```

启动ntp服务

```
service ntpd start
```

设置客户端

```
vim /etc/ntp.conf 
```

```
# Use public servers from the pool.ntp.org project.
# Please consider joining the pool (http://www.pool.ntp.org/join.html).
#server 0.centos.pool.ntp.org iburst
#server 1.centos.pool.ntp.org iburst
#server 2.centos.pool.ntp.org iburst
#server 3.centos.pool.ntp.org iburst
server 192.168.100.10
```

设置ntpd随机启动

```
chkconfig ntpd on
chkconfig ntpd --list
```

检查ntp状态

```
ntpstat
[root@localhost ~]# ntpstat 
synchronised to NTP server (192.168.100.10) at stratum 4 
   time correct to within 7968 ms
   polling server every 64 s
[root@localhost ~]# 
```

```
watch ntpq -p
```
 
## ifconfig

## netstat 

```
netstat -rn 路由表
```

## 查看文件占用

```
du -sh 文件大小
df 磁盘信息
```

## 查看内存使用

```
free 内存信息  -m 以M为单位
```

## 查看操作系统

```
getconfig LONG_BIT  64/32位
```

## xargs命令

```
xargs 	find /sbin -perm +700 |ls -l       这个命令是错误的
find /sbin -perm +700 |xargs ls -l   这样才是正确的
xargs 可以读入 stdin 的资料，并且以空白字元或断行字元作为分辨
```

## find命令

```
find . -name '.project' -print -exec rm -rf {} \; 递归删除
```


## 查看路由信息（经过网关）

```
route -n get default  
route -n get www.google.com
```

## 追踪路由

```
traceroute www.google.com
```

## linux serf

Serf is a tool for cluster membership, failure detection, and orchestration that is decentralized, fault-tolerant and highly available. Serf runs on every major platform: Linux, Mac OS X, and Windows. It is extremely lightweight: it uses 5 to 10 MB of resident memory and primarily communicates using infrequent UDP messages.
https://www.serfdom.io/intro/index.html

## lsof 文件相关信息  pid 端口

```
lsof `which httpd` //那个进程在使用apache的可执行文件
lsof /etc/passwd //那个进程在占用/etc/passwd
lsof /dev/hda6 //那个进程在占用hda6
lsof /dev/cdrom //那个进程在占用光驱
lsof -c sendmail //查看sendmail进程的文件使用情况
lsof -c courier -u ^zahn //显示出那些文件被以courier打头的进程打开，但是并不属于用户zahn
lsof -p 30297 //显示那些文件被pid为30297的进程打开
lsof -D /tmp 显示所有在/tmp文件夹中打开的instance和文件的进程。但是symbol文件并不在列
lsof -u1000 //查看uid是100的用户的进程的文件使用情况
lsof -utony //查看用户tony的进程的文件使用情况
lsof -u^tony //查看不是用户tony的进程的文件使用情况(^是取反的意思)
lsof -i //显示所有打开的端口
lsof -i:80 //显示所有打开80端口的进程
lsof -i -U //显示所有打开的端口和UNIX domain文件
lsof -i UDP@[url]www.akadia.com:123 //显示那些进程打开了到www.akadia.com的UDP的123(ntp)端口的链接
lsof -i tcp@ohaha.ks.edu.tw:ftp -r //不断查看目前ftp连接的情况(-r，lsof会永远不断的执行，直到收到中断信号,+r，lsof会一直执行，直到没有档案被显示,缺省是15s刷新)
lsof -i tcp@ohaha.ks.edu.tw:ftp -n //lsof -n 不将IP转换为hostname，缺省是不加上-n参数
```


## Jenkins 重启dubbo服务脚本

service-restart.sh

```bash
#!/bin/sh

## java env
source /etc/profile
export JAVA_HOME=/usr/local/jdk1.7.0_75
export JRE_HOME=$JAVA_HOME/jre

if [ $# != 3 ] ; then
echo "USAGE: $0 SERVICE_DIR SERVICE_NAME_PRE DISCONF_ENV" 
echo " e.g.: $0 /opt/ync-goods ync-goods rd" 
exit 1;
fi
SERVICE_DIR=$1
SERVICE_NAME_PRE=$2

DISCONF_ENV=$3
DISCONF_HOST=192.168.88.30:8080
DISCONF_APP=cwang
DISCONF_VERSION=1.0.0

cd $SERVICE_DIR

#        P_ID=`ps -ef | grep -w "$SERVICE_NAME_PRE" | grep -v "grep" | awk '{print $2}'`
        P_ID=`jps -ml|grep "$SERVICE_NAME_PRE"|awk '{print $1}'`
        if [ "$P_ID" == "" ]; then
            echo "=== $SERVICE_NAME process not exists or stop success"
        else
            echo "=== begin kill $SERVICE_NAME process, pid is:$P_ID"
            kill -9 $P_ID
       fi

        sleep 3

        JAR_NAME=`ls -rt *.jar|grep -v 'sources'|tail -1`

        echo "START JAR_NAME "$JAR_NAME
        nohup $JRE_HOME/bin/java -Xms256m -Xmx512m -jar   -Ddisconf.env=$DISCONF_ENV -Ddisconf.conf_server_host=$DISCONF_HOST -Ddisconf.app=$DISCONF_APP -Ddisconf.version=$DISCONF_VERSION -Ddisconf.user_define_download_dir=.classes -Ddisconf.enable.remote.conf=true          $JAR_NAME >$SERVICE_NAME_PRE.log 2>&1 &

        ls *.jar|grep -v $JAR_NAME|xargs rm -rf
exit 0

```

service-region.sh 

```bash
#!/bin/sh

## java env
export JAVA_HOME=/usr/local/jdk1.7.0_75
export JRE_HOME=$JAVA_HOME/jre

## service name
APP_NAME=region
SERVICE_DIR=/opt/ync-region

FILE_NAME=`ls /opt/ync-region| grep '.[0-9]'.jar`

SERVICE_NAME=$FILE_NAME
JAR_NAME=$SERVICE_NAME
PID=$SERVICE_NAME\.pid

cd $SERVICE_DIR

case "$1" in

    start)
        nohup $JRE_HOME/bin/java -Xms256m -Xmx512m  -Ddisconf.env=qa -Ddisconf.conf_server_host=192.168.88.30:8080 -Ddisconf.app=cwang -Ddisconf.version=1.0.0 -Ddisconf.user_define_download_dir=.classes -Ddisconf.enable.remote.conf=true    -jar $JAR_NAME >/dev/null 2>&1 &
        echo $! > $SERVICE_DIR/$PID
        echo "=== start $SERVICE_NAME"
        ;;

    stop)
        #kill `cat $SERVICE_DIR/$PID`
        #rm -rf $SERVICE_DIR/$PID
        #echo "=== stop $SERVICE_NAME"

        sleep 5
        P_ID=`ps -ef | grep -w "$SERVICE_NAME" | grep -v "grep" | awk '{print $2}'`
        if [ "$P_ID" == "" ]; then
            echo "=== $SERVICE_NAME process not exists or stop success"
        else
            echo "=== $SERVICE_NAME process pid is:$P_ID"
            echo "=== begin kill $SERVICE_NAME process, pid is:$P_ID"
            #kill -9 $P_ID
        fi
        ;;

    restart)
        $0 stop
        sleep 2
        $0 start
        echo "=== restart $SERVICE_NAME"
        ;;

    *)
        ## restart
        $0 stop
        sleep 2
        $0 start
        ;;
esac
exit 0
```

service-region-tag.sh 

```bash
#!/bin/sh

## java env
export JAVA_HOME=/usr/local/jdk1.7.0_75
export JRE_HOME=$JAVA_HOME/jre

## service name
APP_NAME=region

#find filename
FILE_NAME=`ls /opt/ync-region | grep '.[0-9]'.jar`
echo "FILE_NAME=====================$FILE_NAME"

SERVICE_DIR=/opt/ync-region
SERVICE_NAME=$FILE_NAME
echo "SERVICE_NAME------------------:$SERVICE_NAME"

JAR_NAME=$SERVICE_NAME\.jar
PID=$SERVICE_NAME\.pid

cd $SERVICE_DIR

        if ["$FILE_NAME" == ""];then
                exit 0;
        fi

        sleep 5
        P_ID=`ps -ef | grep -w "$SERVICE_NAME" | grep -v "grep" | awk '{print $2}'`
        echo "P_ID---------------------------:$P_ID"

        if [ "$P_ID" == "" ]; then
            echo "=== $SERVICE_NAME process not exists or stop success"
        else
            echo "=== $SERVICE_NAME process pid is:$P_ID"
            echo "=== begin kill $SERVICE_NAME process, pid is:$P_ID"
            kill -9 $P_ID
       fi

`rm -rf $FILE_NAME`


exit 0
```